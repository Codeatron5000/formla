{"version":3,"file":"Form.min.js","mappings":"CAAA,SAA2CA,EAAMC,GAC1B,iBAAZC,SAA0C,iBAAXC,OACxCA,OAAOD,QAAUD,IACQ,mBAAXG,QAAyBA,OAAOC,IAC9CD,OAAO,GAAIH,GACe,iBAAZC,QACdA,QAAgB,OAAID,IAEpBD,EAAa,OAAIC,IARnB,CASGK,MAAM,WACT,M,sCCRAJ,EAAQK,YAAa,EACrBL,EAAQM,qBAAkB,EAW1BN,EAAQM,gBATc,SAAyBC,GAC7C,IAAIC,EAAMD,EAAKC,IACbC,EAAOF,EAAKE,KACZC,EAAOH,EAAKG,KACdC,KAAKH,IAAMA,EACXG,KAAKF,KAAOA,EACZE,KAAKD,KAAOA,I,cCTdV,EAAQK,YAAa,EACrBL,EAAQY,aAIR,SAASA,EAAaC,EAAOC,QACd,IAATA,IACFA,EAAO,IAGT,IAAIC,EACAC,EAAQ,IAAIC,IAEhB,SAASC,EAAQC,EAAOC,GACtB,IAAIC,EAAcL,EAAMM,IAAIF,GACxBC,EAAaA,EAAYE,KAAKC,MAAMH,EAAaF,GAChDH,EAAMS,IAAIL,EAAMD,GAGvB,GACmB,oBAATO,MAAwBb,aAAiBa,MAChC,oBAATC,MAAwBd,aAAiBc,MACjDd,aAAiBe,EAAiBtB,gBAElCS,EAAQ,KACRG,EAAQ,CAACJ,GAAOD,OACX,CACL,IAAIgB,EAASf,EAAOA,EAAO,IAAM,GACjC,GAAwB,oBAAbgB,UAA4BjB,aAAiBiB,SACtDf,EAAQgB,MAAMC,UAAUC,IAAIC,KAAKrB,GAAO,SAASO,EAAMe,GAErD,OADAjB,EAAQ,CAAC,GAAKW,EAASM,GAAIf,GACpB,aAEN,GAAIW,MAAMK,QAAQvB,GACrBE,EAAQF,EAAMoB,KAAI,SAASI,EAAOF,GAChC,IAAIG,EAAS1B,EAAayB,EAAO,GAAKR,EAASM,GAE/C,OADAG,EAAOtB,MAAMuB,QAAQrB,GACdoB,EAAOvB,cAEb,GAAIF,GAASA,EAAM2B,cAAgBC,OAGtC,IAAK,IAAIN,KAFTpB,EAAQ,GAEMF,EAAO,CACnB,IAAIyB,EAAS1B,EAAaC,EAAMsB,GAAI,GAAKN,EAASM,GAClDG,EAAOtB,MAAMuB,QAAQrB,GACrBH,EAAMoB,GAAKG,EAAOvB,WAEfA,EAAQF,EAGjB,MAAO,CACLE,MAAOA,EACPC,MAAOA,IAjDX,IAAIY,EAAmB,EAAQ,M,cCFL5B,EAAQ,QAAe,EAEjD,IAAI0C,EAAgB,EAAQ,KAE5B1C,EAAQ,GAAe0C,EAAc9B,aAEd,EAAQ,KAEYN,kBCVvCqC,EAA2B,GAG/B,SAASC,EAAoBC,GAE5B,IAAIC,EAAeH,EAAyBE,GAC5C,QAAqBE,IAAjBD,EACH,OAAOA,EAAa9C,QAGrB,IAAIC,EAAS0C,EAAyBE,GAAY,CAGjD7C,QAAS,IAOV,OAHAgD,EAAoBH,GAAU5C,EAAQA,EAAOD,QAAS4C,GAG/C3C,EAAOD,QCpBf4C,EAAoBK,EAAI,CAACjD,EAASkD,KACjC,IAAI,IAAIC,KAAOD,EACXN,EAAoBQ,EAAEF,EAAYC,KAASP,EAAoBQ,EAAEpD,EAASmD,IAC5EV,OAAOY,eAAerD,EAASmD,EAAK,CAAEG,YAAY,EAAMhC,IAAK4B,EAAWC,MCJ3EP,EAAoBQ,EAAI,CAACG,EAAKC,IAAUf,OAAOT,UAAUyB,eAAevB,KAAKqB,EAAKC,GCClFZ,EAAoBc,EAAK1D,IACH,oBAAX2D,QAA0BA,OAAOC,aAC1CnB,OAAOY,eAAerD,EAAS2D,OAAOC,YAAa,CAAE/C,MAAO,WAE7D4B,OAAOY,eAAerD,EAAS,aAAc,CAAEa,OAAO,K,gECJvD,MAAM4C,EAAiBhB,OAAOT,UAAUyB,eAEjC,SAASI,EAAQN,EAAaJ,GACjC,OAAOM,EAAevB,KAAKqB,EAAKJ,GAG7B,SAASW,EAAOC,GACnB,QAASA,GAAQA,aAAepC,KAG7B,SAASZ,EAAMwC,GAClB,GAAIS,EAAMT,GACN,OAAOA,EAAItB,IAAIlB,GAEnB,GAAIwC,MAAAA,EACA,OAAO,KAEX,GAAIO,EAAOP,IAAQ,CAAC,SAAU,SAAU,WAAWU,gBAAgBV,GAC/D,OAAOA,EAEX,GAAIW,EAAMX,GAAM,CACZ,IAAIY,EAAS,GAIb,OAFA1B,OAAO2B,KAAKb,GAAKhB,SAASY,GAAQgB,EAAOhB,GAAOpC,EAAMwC,EAAIJ,MAEnDgB,GAiBR,SAASD,EAAMrD,GAClB,OAAiB,OAAVA,GAAmC,iBAAVA,EAG7B,SAASmD,EAAMnD,GAClB,OAAOA,aAAiBkB,MAGrB,SAASsC,EAAMxD,GAClB,OAAgB,MAATA,EAOJ,SAASyD,EAAMzD,GAClB,MAAwB,iBAAVA,EAOX,SAAS0D,EAAahB,GACzB,GAAIS,EAAMT,GACN,IAAK,IAAIpB,EAAI,EAAGA,EAAIoB,EAAIiB,OAAQrC,IAAK,CACjC,GAAIoB,EAAIpB,aAAcT,KAClB,OAAO,EAEX,GAAIwC,EAAMX,EAAIpB,IACV,OAAOoC,EAAahB,EAAIpB,SAIhC,IAAK,IAAIgB,KAAOI,EAAK,CACjB,GAAIA,EAAIJ,aAAgBzB,KACpB,OAAO,EAEX,GAAIwC,EAAMX,EAAIJ,IACV,OAAOoB,EAAahB,EAAIJ,IAIpC,OAAO,EAGJ,SAASsB,EAAcC,GAC1B,IAAIP,EAAS,GAMb,OAJAO,EAAMnC,SAAQ,CAACoC,EAAMC,KACjBT,EAAOS,GAASD,KAGbR,E,wHCwEX,QAnKA,MAQI3B,cAAc,kDACV7B,KAAKkE,OAAS,GACdlE,KAAKmE,SAAW,GAQpBC,IAAIC,GACA,OAAIA,aAAiBC,OACVxC,OAAO2B,KAAKzD,KAAKkE,QAAQK,MAAK/B,GAAO6B,EAAMG,KAAKhC,KAEpDxC,KAAKkE,OAAOpB,eAAeuB,GAMtCI,MACI,OAAO3C,OAAO2B,KAAKzD,KAAKkE,QAAQL,OAAS,EAQ7Ca,SAASL,GAAwD,IAAzCM,IAAyC,yDACzDC,EAAQ5E,KAAKW,IAAI0D,EAAOM,GAC5B,GAAIC,EACA,OAAIvB,EAAMuB,GACCA,EAAMf,OAASe,EAAM,GAAK,KAE1BA,GAAS,KAK5BjE,IAAI0D,GAA+C,IAAhCM,IAAgC,yDAC/C,GAAIN,EAAMf,SAAS,MAAQqB,EAAgB,CACvC,MAAME,EAAYR,EAAMS,QAAQ,qBAAsB,QACjDA,QAAQ,IAAK,QACZC,EAAS,IAAIT,OAAOO,GAC1B,IAAIX,EAAS,GAWb,OAVApC,OAAO2B,KAAKzD,KAAKkE,QAAQtC,SAASY,IAC9B,GAAIuC,EAAOP,KAAKhC,GAAM,CAClB,MAAMwC,EAAYhF,KAAKkE,OAAO1B,GAC1Ba,EAAM2B,GACNd,EAASA,EAAOe,OAAOD,GAEvBd,EAAOtD,KAAKoE,OAIjBd,EAEX,OAAOlE,KAAKkE,OAAOG,GAUvBa,IAAIb,EAAeO,GAA2C,IAAxBO,EAAwB,wDACrDnF,KAAKoE,IAAIC,KAAUc,IACpBnF,KAAKkE,OAAOG,GAASO,GAU7BQ,OAAOlB,GAAwD,IAAnCmB,EAAmC,uDAAN,IACrDrF,KAAKkE,OAASA,EACVmB,GACAC,OAAOC,YAAW,KACdvF,KAAKwF,UACNH,GASXG,MAAMnB,GACEA,SACOrE,KAAKkE,OAAOG,GAKvBrE,KAAKkE,OAAS,GAGlBuB,WAAWjD,EAAiCkD,GACpCrC,EAAMb,GACNA,EAAIZ,SAAQyC,GAASrE,KAAKyF,WAAWpB,EAAOqB,KAE5C1F,KAAKmE,SAASvD,KAAK,CAAE4B,IAAAA,EAAKkD,GAAAA,IAIlCC,cAAcC,GACV5F,KAAKmE,SAAWnE,KAAKmE,SAAS0B,QAAO,QAAC,GAAEH,GAAH,SAAYA,IAAOE,KAG5DE,iBAAiBzB,GACThB,EAAMgB,GACNA,EAAMzC,SAAQY,GAAOxC,KAAK8F,iBAAiBtD,KAE3CxC,KAAKmE,SAAWnE,KAAKmE,SAAS0B,QAAO,QAAC,IAAErD,GAAH,SAAaA,IAAQ6B,KAIlE0B,cACI,QAAS/F,KAAKmE,SAASN,OAG3BmC,gBAIU,IAJIC,EAIJ,uDAAN,KACAA,EAAUvC,EAAMuC,GAAW,CAAEC,SAAU,SAAUC,OAAQ,UAAaF,EAEtE,MAAML,EAAU5F,KAAKmE,SAASiC,MAAK,IAAiB,IAC5CC,GAD4B,IAAE7D,EAAF,GAAOkD,GAAS,EAEhD,GAAIlD,aAAe8B,OACf+B,EAAK7D,MACF,CACH,IAAI8D,EAA0B9D,ED1F5BsC,QAAQ,sBAAuB,QC2FjCuB,EAAK,IAAI/B,OAAOgC,EAAWxB,QAAQ,IAAK,OAG5C,GAAIhD,OAAO2B,KAAKzD,KAAKkE,QAAQK,MAAK/B,GAAO6D,EAAG7B,KAAKhC,KAC7C,OAAO,KAIXoD,ID/DL,SAAsBF,GACzB,MAAMa,EAAcb,EAAGc,wBAEvB,OAAOD,EAAYE,KAAO,GAAKF,EAAYG,SAAWpB,OAAOqB,aAAerB,OAAOsB,SAASC,gBAAgBC,cC4DxFC,CAAanB,EAAQF,KACjCE,EAAQF,GAAGsB,eAAef,K,wHC7HtC,SAASnF,EAAI8B,EAAgBa,EAA8BvD,IACnDyD,EAAMF,IAA0B,iBAATA,KACvBA,GAAQ,GAAGA,GAAMwD,MAAM,MAG3B,IAAIzE,EAAMiB,EAAKyD,QAEV3D,EAAMX,KAAQO,EAAOP,KAIrBa,EAAKI,QAODX,EAAON,EAAKJ,KACTa,EAAMT,GACNA,GAAKJ,GAAe,MAARA,EAAc,GAAK,GAE/BI,EAAIJ,GAAe,MAARA,EAAc,GAAK,IAGlCa,EAAMT,GACN9B,EAAI8B,GAAKJ,GAAMiB,EAAMvD,GAErBY,EAAI8B,EAAIJ,GAAMiB,EAAMvD,IAhBpBmD,EAAMT,GACNA,GAAKJ,GAAOtC,EAEZ0C,EAAIJ,GAAOtC,GAkBvB,SAASS,EAAIiC,EAAgBa,GACrBE,EAAMF,KACNA,EAAOA,EAAKwD,MAAM,MAGtB,IAMItF,EANAa,EAAMiB,EAAKyD,QAEf,GAAK3D,EAAMX,KAAQO,EAAOP,IAASM,EAAON,EAAKJ,GAc/C,OAPIb,EADA0B,EAAMT,GACGA,GAAKJ,GACPe,EAAMX,KAASO,EAAOP,GACpBA,EAAIJ,QAEJJ,EAGRqB,EAAKI,YAGVlD,EAAIgB,EAAQ8B,GAFD9B,EAiBf,SAASwF,EAAqBC,GAAwF,IAAzDlG,EAAyD,uDAAxC,GACtEmG,EAAS,GAkCb,OAhCIhE,EAAM+D,GACNA,EAAKxF,SAAQoC,IACT,IAAIsD,EAAY,GAAEpG,OAEdqC,EAAMS,IAAUb,EAAOa,GAQ3BqD,EAAOC,GAAYnE,EAAOa,GAAQA,EAAOuD,EAAkBvD,GAPvDqD,EAAS,IACFA,KACAF,EAAqBnD,EAAMsD,OAQ1CxF,OAAO2B,KAAK2D,GAAMxF,SAAQY,IACtB,IAAIwB,EAAOoD,EAAK5E,GAEZ8E,EAAWpG,EAAU,GAAEA,KAAUsB,KAAS,GAAKA,GAE/Ce,EAAMS,IAAUb,EAAOa,GAQ3BqD,EAAOC,GAAYnE,EAAOa,GAAQA,EAAOuD,EAAkBvD,GAPvDqD,EAAS,IACFA,KACAF,EAAqBnD,EAAMsD,OASvCD,EAGX,SAASE,EAAkBrH,GACvB,MAAqB,kBAAVA,EACA,KAAKA,EAEK,iBAAVA,EACAA,EAAMsH,WAEVtH,GAAS,GAsBpB,MAAMuH,EAwFF5F,YAAYuF,EAAmBnB,GAAmB,yKAC9CjG,KAAK0H,WAAWzB,GAELmB,aFrNSO,WEsNhB3H,KAAK4H,QAAUR,EACfA,EAAOA,KAGXpH,KAAK6H,cAAgB,GACrB7H,KAAK8H,sBAAwB,GAC7B9H,KAAK+H,MAAQ,GAGb/H,KAAKgI,OAAOZ,OAAMhF,GAAW,GAAO,GAEpCpC,KAAKiI,QAAU,IAAIC,EAGvBR,WAAWzB,GACPjG,KAAKmI,SAAWnI,KAAKmI,UAAYV,EAAKW,eAClCnC,IACAjG,KAAKmI,SAAW,IACTnI,KAAKmI,YACLlC,IAKf+B,OAAOxF,EAAoBtC,GAAwF,IAAtEmI,EAAsE,wDAA1CC,IAA0C,yDAC/G,GAAItI,KAAK4H,UAAYS,GAAYrI,KAAKmI,SAASI,yBAA2BD,EAAmB,CACzF,MAAME,EAAaxI,KAAK4H,QACxB5H,KAAK4H,QAAU,KACX,MAAMR,EAAOoB,IACb,OAAIjF,EAAMf,GACC,IACA4E,KACA5E,GAGJ,IACA4E,EACH,CAAC5E,GAAMtC,IAKnB,OAAIqD,EAAMf,IACNV,OAAO2B,KAAKjB,GAAKZ,SAAQyC,IACrBrE,KAAKgI,OAAO3D,EAAO7B,EAAI6B,GAAQgE,GAAU,MAEtCrI,OAGXE,EAAQF,KAAKyI,UAAUvI,GACnBmI,EACAvH,EAAId,KAAK8H,sBAAuBtF,EAAKtC,GAErCY,EAAId,KAAK6H,cAAerF,EAAKxC,KAAKyI,UAAUvI,IAE3CmI,EAIDvG,OAAOY,eACH1C,KACAwC,EACA,CACI7B,IAAK,OACLG,IAAK,KACD,MAAM,IAAI4H,MAAO,QAAOlG,gEATpC1B,EAAId,KAAK+H,MAAOvF,EAAKtC,GACrBF,KAAK0C,eAAeF,IAcjBxC,MAGX0C,eAAeF,GACXV,OAAOY,eACH1C,KACAwC,EACA,CACImG,cAAc,EACdhG,YAAY,EACZhC,IAAK,IAAMA,EAAIX,KAAK+H,MAAOvF,GAC3B1B,IAAM8H,IACF5I,KAAK6I,QAAQrG,EAAKoG,MAMlCE,aAAatG,EAAoBtC,GAC7B,OAAOF,KAAKgI,OAAOxF,EAAKtC,GAAO,GAAM,GAGzC6I,UACI,MAAO,IACA/I,KAAK+H,SACL/H,KAAK8H,uBAIhBe,QAAQrG,EAAatC,GACjBY,EAAId,KAAK+H,MAAOvF,EAAKtC,GACjBF,KAAKmI,SAASa,iBACdhJ,KAAKiI,QAAQzC,MAAMhD,GAI3B0B,SACI,OAAOlE,KAAKiI,QAGhBgB,QACI,MAAMC,EAAelJ,KAAK4H,QAAU5H,KAAK4H,UAAY5H,KAAK6H,cAE1D,IAAK,IAAIxD,KAASrE,KAAK+H,aAEZ/H,KAAKqE,GAUhB,OAPArE,KAAK6H,cAAgB,GACrB7H,KAAK+H,MAAQ,GAEb/H,KAAKgI,OAAOkB,OAAc9G,GAAW,GAAO,GAE5CpC,KAAKiI,QAAQzC,QAENxF,KAGXwF,MAAMnB,GFjXH,IAAoB8E,EEqXnB,OAHIjG,EAAOlD,KAAMqE,IACbvD,EAAId,KAAK+H,MAAO1D,GFnXD8E,EEmXmBxI,EAAIX,KAAK+H,MAAO1D,cFlXlCjD,MACb,GAEa,iBAAb+H,EACA,GAEa,iBAAbA,EACA,GAEJ,ME2WInJ,KAGXyI,UAAUrB,GACN,OAAOpH,KAAKmI,SAAS/H,MAAQA,EAAMgH,GAAQA,EAG/CgC,iBAAiBC,EAA0B7G,GACvC,IAAI8G,EAAOD,EAAM7F,OACjB,KAAM8F,aAAgBC,kBAClB,MAAM,IAAIb,MAAM,+DAapB,OAXKlG,IACDA,EAAM8G,EAAKxJ,MAEX0C,KAAOxC,MAAwB,KAAfsJ,EAAKpJ,QACjBmJ,aAAiBG,UACjBxJ,KAAK6I,QAAQrG,EAAK6G,EAAMI,cAAgBJ,EAAMI,aAAapJ,MAAMwD,QAAUwF,EAAMI,aAAapJ,MAAM,IAEpGL,KAAK6I,QAAQrG,EAAK8G,EAAKjJ,OAASiJ,EAAKjJ,MAAMwD,QAAUyF,EAAKjJ,MAAM,IAEpEiJ,EAAKpJ,MAAQ,IAEVF,KAGX0J,KAAKC,EAAuB1D,GACxB,OAAOjG,KAAK4J,OAAO,OAAQD,EAAK1D,GAGpC4D,IAAIF,EAAuB1D,GACvB,OAAOjG,KAAK4J,OAAO,MAAOD,EAAK1D,GAGnC6D,MAAMH,EAAuB1D,GACzB,OAAOjG,KAAK4J,OAAO,QAASD,EAAK1D,GAGrC8D,OAAOJ,EAAuB1D,GAC1B,OAAOjG,KAAK4J,OAAO,SAAUD,EAAK1D,GAGtCtF,IAAIgJ,EAAuB1D,GACvB,OAAOjG,KAAK4J,OAAO,MAAOD,EAAK1D,GAGnC+D,QAAQC,EAAehE,GAEnB,MAAMiE,GADNjE,EAAUA,GAAW,IACsBkE,YAAcnK,KAAKmI,SAASgC,WAwBvE,OAtBAlE,EAAQ0D,IAAM1D,EAAQ+D,SAAWhK,KAAKmI,SAAS6B,QAE/C/D,EAAQmE,SAAWpK,KAAKqK,UAExBpE,EAAQkE,WAAc/C,IAClBA,EAAO8C,EAA6BA,EAA2B9C,GAAQA,EACvE,MAAMkD,EAAa,CACfL,MAAAA,EACAM,UAAWnD,GAGf,IAAKpH,KAAKqK,UACN,OAAOC,EAEX,MAAM,MAAElK,EAAF,MAASC,IAAUJ,EAAAA,EAAAA,IAAamH,GAEtC,OADAkD,EAAWC,UAAYnK,EAChB,CACHkK,WAAYE,KAAKC,UAAUH,GAC3BhJ,IAAKkJ,KAAKC,UAAU3G,EAAc1C,MAAMsJ,KAAKrK,EAAMsK,eAChD7G,EAAc1C,MAAMsJ,KAAKrK,EAAMoD,WAGnCzD,KAAK0J,KAAKzD,GAGrB2D,OAAOgB,EAA0BjB,EAAwB1D,GACrDA,EA5XR,SAAsB2E,EAAoCjB,EAAiC1D,GAKvF,OAJA2E,EAASA,EAAUrH,EAAMqH,GAAUA,EAAS,CAAEA,OAAAA,GAAY,GAC1DjB,EAAMA,EAAOpG,EAAMoG,GAAOA,EAAM,CAAEA,IAAAA,GAAS,GAC3C1D,EAAUA,GAAW,GAEd,IACAA,KACA0D,KACAiB,GAoXOC,CAAaD,EAAQjB,EAAK1D,GACpC,MAAM6E,EAAiB,IAChB9K,KAAKmI,YACLlC,GAGP,IAAI8E,EAAU3D,EAAO0D,EAAeX,WAAWnK,KAAK+I,WACpD,GAAI/I,KAAKgL,wBAAwBF,GAAiB,CAC9CC,EAAW,IAAIE,SAEf,IAAI5D,EAASF,EAAqBC,GAElCtF,OAAO2B,KAAK4D,GAAQzF,SAAQY,IACxBuI,EAAS/C,OAAOxF,EAAK6E,EAAO7E,OAGhC4E,EAAO2D,EAKX,OAAOG,EAFWJ,EAAeK,UAEdL,EAAeF,OAAQ5K,KAAKoL,aAAaN,GAAiB1D,EAAM0D,GAAgBO,MAAKC,IAChGR,EAAeS,kBAAkBD,GACjCtL,KAAKwL,OAAOF,EAAUR,GAEtB9K,KAAKyL,UAAUX,GAEZQ,KACRI,OAAM9G,IACDkG,EAAeS,kBAAkB3G,IACjC5E,KAAKwL,OAAO5G,EAAOkG,GA9VnC,SAAqBlG,GACjB,GAAIA,aAAiB8D,MACjB,MAAM9D,EAEV,OAAO+G,QAAQC,OAAOhH,GA4VPiH,CAAYjH,MAI3BoG,wBAAwB/E,GAEpB,OADAA,EAAUA,GAAWjG,KAAKmI,UACd2D,YACA7F,EAAQmE,SAEZnE,EAAQmE,SAAWpK,KAAKqK,UAGpCA,UACI,OAAOzG,EAAa5D,KAAK+I,WAG7B0C,UAAUxF,IACNA,EAAUA,GAAWjG,KAAKmI,UACd3C,OACRxF,KAAKiJ,QAIbuC,OAAO5G,EAAuBqB,GAE1B,KADAA,EAAUA,GAAWjG,KAAKmI,UACb4D,MAAO,CAChB,IAAI7H,EAAS+B,EAAQ+F,oBAAoBpH,GACzC5E,KAAKiI,QAAQ7C,OAAOlB,EAAQ+B,EAAQZ,SAChCrF,KAAKiI,QAAQlC,eACb/F,KAAKiI,QAAQjC,iBAKzBoF,aAAanF,GAET,IADAA,EAAUA,GAAWjG,KAAKmI,UACdwB,IAAIrG,SAAS,OACrB,OAAO2C,EAAQ0D,IAEnB,IAAIsC,EAAUhG,EAAQgG,QAClBC,EAAcjG,EAAQ0D,IAK1B,OAHAsC,EAAUA,EAAQnH,QAAQ,QAAS,IACnCoH,EAAcA,EAAYpH,QAAQ,QAAS,IAEnC,GAAEmH,KAAWC,IAGzBC,QAAQlG,GACJ,IAAI0D,EAAM3J,KAAKoL,aAAanF,GACxBmG,EAAazC,EAAIrG,SAAS,KAAO,IAAM,IACvC+I,EAAU1C,EAAMyC,EAChBE,EAAa,GAGbjF,EAASF,EAFFnH,KAAK+I,WAahB,OATAjH,OAAO2B,KAAK4D,GAAQzF,SAAQY,IACxB,IAAIwB,EAAOqD,EAAO7E,GAElB,GAAIW,EAAOa,GACP,MAAM,IAAI0E,MAAM,mCAGpB4D,EAAW1L,KAAK4B,GAAOkB,EAAMM,GAAQ,GAAM,IAAGA,SAE3CqI,EAAUC,EAAWC,KAAK,KAGrC9G,WAAWjD,EAAakD,GACpB1F,KAAKiI,QAAQxC,WAAWjD,EAAKkD,GAGjCC,cAAcD,GACV1F,KAAKiI,QAAQtC,cAAcD,GAG/BI,iBAAiBtD,GACbxC,KAAKiI,QAAQnC,iBAAiBtD,I,EA3ZhCiF,EAAAA,iBAU+B,CAE7BmD,OAAQ,OAGRqB,QAAS,GAGTtC,IAAK,GAGLK,QAAS,UAKTmB,SCnMO,SAAcP,EAAgBjB,EAAavC,EAAuBnB,GAC7E,IAAIuG,EAAM,IAAIC,eAEVnB,EAAW,IAAIK,SAAwB,CAACe,EAASd,KACjDY,EAAIG,OAAS,KACLH,EAAII,QAAU,KAAOJ,EAAII,OAAS,IAClCF,EAAQF,GAERZ,EAAOY,IAGfA,EAAIK,QAAU,IAAMjB,EAAOY,MAY/B,OATAA,EAAIM,KAAKlC,EAAQjB,GACbvC,aAAgB6D,UAChBuB,EAAIO,iBAAiB,eAAgB,uBACrCP,EAAIQ,KAAK5F,KAEToF,EAAIO,iBAAiB,eAAgB,oBACrCP,EAAIQ,KAAKxC,KAAKC,UAAUrD,KAGrBkE,GDiLHlB,SAAS,EAGT0B,YAAY,EAGZP,kBAAmB,QAAC,OAAEqB,GAAH,SAA2B,MAAXA,GAGnCzC,WAAa/C,GAASA,EAGtB4E,oBAAsBV,IAClB,IAAIlE,EAAOkE,EAASlE,MAAQkE,EAASA,SACrC,GAAoB,iBAATlE,EACP,IACIA,EAAOoD,KAAKyC,MAAM7F,GACpB,MAAO8F,GACL,MAAM,IAAIxE,MAAM,yCAGxB,IAAIxE,EAAsBkD,EAAKlD,OAC/B,GAjEZ,SAA4BA,GACxB,OAAQA,GACc,iBAAXA,IACNpC,OAAO2B,KAAKS,GAAQL,QACrB/B,OAAO6I,OAAOzG,GAAQK,MAAKK,GACnBvB,EAAMuB,GACCA,EAAML,MAAK4I,IAAYxJ,EAAMwJ,MAEhCxJ,EAAMiB,KAyDVwI,CAAmBlJ,GACnB,MAAM,IAAIwE,MAAM,yCAEpB,OAAOxE,GAKXmB,SAAS,EAGT2D,iBAAiB,EAGjBxD,OAAO,EAGPuG,OAAO,EAGP3L,OAAO,EAKPmI,yBAAyB,I,EA9E3Bd,EAAAA,cAiFkB,SAAUxB,GAC1BwB,EAAKW,eAAiB,IACfX,EAAKW,kBACLnC,MA4Uf,W","sources":["webpack://formla/webpack/universalModuleDefinition","webpack://formla/./node_modules/extract-files/lib/ReactNativeFile.js","webpack://formla/./node_modules/extract-files/lib/extractFiles.js","webpack://formla/./node_modules/extract-files/lib/index.js","webpack://formla/webpack/bootstrap","webpack://formla/webpack/runtime/define property getters","webpack://formla/webpack/runtime/hasOwnProperty shorthand","webpack://formla/webpack/runtime/make namespace object","webpack://formla/./src/utils.js","webpack://formla/./src/Errors.js","webpack://formla/./src/Form.js","webpack://formla/./src/http.js"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"formla\"] = factory();\n\telse\n\t\troot[\"formla\"] = factory();\n})(self, function() {\nreturn ","'use strict'\n\nexports.__esModule = true\nexports.ReactNativeFile = void 0\n\nvar ReactNativeFile = function ReactNativeFile(_ref) {\n  var uri = _ref.uri,\n    name = _ref.name,\n    type = _ref.type\n  this.uri = uri\n  this.name = name\n  this.type = type\n}\n\nexports.ReactNativeFile = ReactNativeFile\n","'use strict'\n\nexports.__esModule = true\nexports.extractFiles = extractFiles\n\nvar _ReactNativeFile = require('./ReactNativeFile')\n\nfunction extractFiles(value, path) {\n  if (path === void 0) {\n    path = ''\n  }\n\n  var clone\n  var files = new Map()\n\n  function addFile(paths, file) {\n    var storedPaths = files.get(file)\n    if (storedPaths) storedPaths.push.apply(storedPaths, paths)\n    else files.set(file, paths)\n  }\n\n  if (\n    (typeof File !== 'undefined' && value instanceof File) ||\n    (typeof Blob !== 'undefined' && value instanceof Blob) ||\n    value instanceof _ReactNativeFile.ReactNativeFile\n  ) {\n    clone = null\n    addFile([path], value)\n  } else {\n    var prefix = path ? path + '.' : ''\n    if (typeof FileList !== 'undefined' && value instanceof FileList)\n      clone = Array.prototype.map.call(value, function(file, i) {\n        addFile(['' + prefix + i], file)\n        return null\n      })\n    else if (Array.isArray(value))\n      clone = value.map(function(child, i) {\n        var result = extractFiles(child, '' + prefix + i)\n        result.files.forEach(addFile)\n        return result.clone\n      })\n    else if (value && value.constructor === Object) {\n      clone = {}\n\n      for (var i in value) {\n        var result = extractFiles(value[i], '' + prefix + i)\n        result.files.forEach(addFile)\n        clone[i] = result.clone\n      }\n    } else clone = value\n  }\n\n  return {\n    clone: clone,\n    files: files\n  }\n}\n","'use strict'\n\nexports.__esModule = true\nexports.ReactNativeFile = exports.extractFiles = void 0\n\nvar _extractFiles = require('./extractFiles')\n\nexports.extractFiles = _extractFiles.extractFiles\n\nvar _ReactNativeFile = require('./ReactNativeFile')\n\nexports.ReactNativeFile = _ReactNativeFile.ReactNativeFile\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","// @flow\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\n\nexport function hasOwn (obj: Object, key: string): boolean %checks {\n    return hasOwnProperty.call(obj, key)\n}\n\nexport function isFile(val: mixed): boolean %checks {\n    return !!val && (val instanceof Blob);\n}\n\nexport function clone(obj: any): any {\n    if (isArr(obj)) {\n        return obj.map(clone);\n    }\n    if (obj === null || obj === undefined) {\n        return null;\n    }\n    if (isFile(obj) || ['number', 'string', 'boolean'].includes(typeof obj)) {\n        return obj;\n    }\n    if (isObj(obj)) {\n        let target = {};\n\n        Object.keys(obj).forEach((key) => target[key] = clone(obj[key]));\n\n        return target;\n    }\n}\n\nexport function emptyValue(original: mixed): Array<any> | {} | '' | null {\n    if (original instanceof Array) {\n        return [];\n    }\n    if (typeof original === 'object') {\n        return {};\n    }\n    if (typeof original === 'string') {\n        return '';\n    }\n    return null;\n}\n\nexport function isObj(value: mixed): boolean %checks {\n    return value !== null && typeof value === 'object';\n}\n\nexport function isArr(value: mixed): %checks {\n    return value instanceof Array;\n}\n\nexport function isNil(value: mixed): %checks {\n    return value == null;\n}\n\nexport function isFunc(value: mixed): %checks {\n    return value instanceof Function;\n}\n\nexport function isStr(value: mixed): %checks {\n    return typeof value === 'string';\n}\n\nexport function escapeRegExp(string: string) {\n    return string.replace(/[\\\\^$.*+?()[\\]{}|]/g, '\\\\$&');\n}\n\nexport function containsFile(obj: any): boolean {\n    if (isArr(obj)) {\n        for (let i = 0; i < obj.length; i++) {\n            if (obj[i] instanceof File) {\n                return true;\n            }\n            if (isObj(obj[i])) {\n                return containsFile(obj[i]);\n            }\n        }\n    } else {\n        for (let key in obj) {\n            if (obj[key] instanceof File) {\n                return true;\n            }\n            if (isObj(obj[key])) {\n                return containsFile(obj[key]);\n            }\n        }\n    }\n    return false;\n}\n\nexport function arrayToObject(array: any[]): { [string]: any } {\n    let target = {};\n\n    array.forEach((item, index) => {\n        target[index] = item;\n    });\n\n    return target;\n}\n\nexport function isInViewport(el: Element) {\n    const boundingBox = el.getBoundingClientRect();\n    // $FlowFixMe\n    return boundingBox.top >= 0 && boundingBox.bottom <= (window.innerHeight || window.document.documentElement.clientHeight);\n}\n","// @flow\nimport { escapeRegExp, isArr, isInViewport, isNil } from \"./utils\";\n\ntype ErrorValue = string | Array<string>;\nexport type ErrorValues = { [string]: ErrorValue };\n\nclass Errors {\n\n    errors: ErrorValues;\n    elements: Array<{ key: string | RegExp, el: Element }>;\n\n    /**\n     * Create a new Errors instance.\n     */\n    constructor() {\n        this.errors = {};\n        this.elements = [];\n    }\n\n    /**\n     * Determine if an errors exists for the given field.\n     *\n     * @param {string|RegExp} field\n     */\n    has(field: string | RegExp): boolean {\n        if (field instanceof RegExp) {\n            return Object.keys(this.errors).some(key => field.test(key));\n        }\n        return this.errors.hasOwnProperty(field);\n    }\n\n    /**\n     * Determine if we have any errors.\n     */\n    any(): boolean {\n        return Object.keys(this.errors).length > 0;\n    }\n\n    /**\n     * Retrieve the error message for a field.\n     *\n     * @param {string} field\n     */\n    getFirst(field: string, matchWildCards: boolean = true): ?string {\n        let error = this.get(field, matchWildCards);\n        if (error) {\n            if (isArr(error)) {\n                return error.length ? error[0] : null;\n            } else {\n                return error || null;\n            }\n        }\n    }\n\n    get(field: string, matchWildCards: boolean = true) {\n        if (field.includes('*') && matchWildCards) {\n            const regExpStr = field.replace(/[.+?^${}()|[\\]\\\\]/g, '\\\\$&')\n                .replace('*', '(.*)');\n            const regExp = new RegExp(regExpStr);\n            let errors = [];\n            Object.keys(this.errors).forEach((key) => {\n                if (regExp.test(key)) {\n                    const keyErrors = this.errors[key];\n                    if (isArr(keyErrors)) {\n                        errors = errors.concat(keyErrors);\n                    } else {\n                        errors.push(keyErrors);\n                    }\n                }\n            });\n            return errors;\n        }\n        return this.errors[field];\n    }\n\n    /**\n     * Add a new error message if one doesn't already exist.\n     *\n     * @param {string} field\n     * @param error\n     * @param force\n     */\n    add(field: string, error: ErrorValue, force: boolean = false) {\n        if (!this.has(field) || force) {\n            this.errors[field] = error;\n        }\n    }\n\n    /**\n     * Record the new errors.\n     *\n     * @param {object} errors\n     * @param timeout\n     */\n    record(errors: ErrorValues, timeout: ?(false | number) = 3000) {\n        this.errors = errors;\n        if (timeout) {\n            window.setTimeout(() => {\n                this.clear();\n            }, timeout);\n        }\n    }\n\n    /**\n     * Clear one or all error fields.\n     *\n     * @param {string|null} field\n     */\n    clear(field: ?string) {\n        if (field) {\n            delete this.errors[field];\n\n            return;\n        }\n\n        this.errors = {};\n    }\n\n    addElement(key: string | RegExp | string[], el: Element) {\n        if (isArr(key)) {\n            key.forEach(field => this.addElement(field, el));\n        } else {\n            this.elements.push({ key, el });\n        }\n    }\n\n    removeElement(element: Element) {\n        this.elements = this.elements.filter(({ el }) => el !== element);\n    }\n\n    removeElementKey(field: string | RegExp | string[]) {\n        if (isArr(field)) {\n            field.forEach(key => this.removeElementKey(key));\n        } else {\n            this.elements = this.elements.filter(({ key }) => key !== field);\n        }\n    }\n\n    hasElements(): boolean {\n        return !!this.elements.length;\n    }\n\n    scrollToFirst(options: ?boolean | {\n        behavior?: ('auto' | 'instant' | 'smooth'),\n        block?: ('start' | 'center' | 'end' | 'nearest'),\n        inline?: ('start' | 'center' | 'end' | 'nearest'),\n    } = null) {\n        options = isNil(options) ? { behavior: 'smooth', inline: 'center' } : options;\n\n        const element = this.elements.find(({ key, el }) => {\n            let rx: RegExp;\n            if (key instanceof RegExp) {\n                rx = key;\n            } else {\n                let expression = escapeRegExp(key);\n                rx = new RegExp(expression.replace('*', '.*'));\n            }\n\n            if (Object.keys(this.errors).some(key => rx.test(key))) {\n                return true;\n            }\n        });\n\n        if (element && !isInViewport(element.el)) {\n            element.el.scrollIntoView(options);\n        }\n    }\n}\n\nexport default Errors;\n","// @flow\nimport { extractFiles } from 'extract-files';\nimport type { ErrorValues } from './Errors';\nimport Errors from './Errors';\nimport type { Method } from './flow';\nimport http from './http';\nimport { arrayToObject, clone, containsFile, emptyValue, hasOwn, isArr, isFile, isNil, isObj, isStr, isFunc } from './utils';\n\ntype PrimitiveFormValue = string | number | boolean | null | typeof undefined;\n\ntype ScalarFormValue = PrimitiveFormValue | Blob | File;\n\ntype FormValue = ScalarFormValue | Array<?FormValue> | { [string]: ?FormValue };\n\nexport type Data = { [string]: FormValue };\n\ntype DataCb = () => Data;\n\ntype Options = {\n    method: Method,\n    baseUrl: string,\n    url: string,\n    graphql: string,\n    sendWith: (method: Method, url: string, data: FormData | Data, options: Options) => Promise<any>,\n    useJson: boolean,\n    strictMode: boolean,\n    isValidationError: ({ status: number }) => boolean,\n    formatData: (Data) => Data,\n    formatErrorResponse: (any) => ErrorValues,\n    timeout: false | number,\n    autoRemoveError: boolean,\n    clear: boolean,\n    quiet: boolean,\n    clone: boolean,\n    addAppendToDataCallback: boolean,\n}\n\ntype PartialOptions = $Shape<Options>;\n\nfunction set(obj: FormValue, keys: number|string|string[], value: FormValue) {\n    if (isStr(keys) || (typeof keys === 'number')) {\n        keys = (''+keys).split('.');\n    }\n\n    let key = keys.shift();\n\n    if (!isObj(obj) || isFile(obj)) {\n        return;\n    }\n\n    if (!keys.length) {\n        if (isArr(obj)) {\n            obj[+key] = value;\n        } else {\n            obj[key] = value;\n        }\n    } else {\n        if (!hasOwn(obj, key)) {\n            if (isArr(obj)) {\n                obj[+key] = key === '0' ? [] : {};\n            } else {\n                obj[key] = key === '0' ? [] : {};\n            }\n        }\n        if (isArr(obj)) {\n            set(obj[+key], keys, value);\n        } else {\n            set(obj[key], keys, value);\n        }\n    }\n}\n\nfunction get(obj: FormValue, keys: string|string[]): FormValue {\n    if (isStr(keys)) {\n        keys = keys.split('.');\n    }\n\n    let key = keys.shift();\n\n    if (!isObj(obj) || isFile(obj) || !hasOwn(obj, key)) {\n        return undefined;\n    }\n\n    let result: FormValue;\n\n    if (isArr(obj)) {\n        result = obj[+key];\n    } else if (isObj(obj) && !isFile(obj)) {\n        result = obj[key];\n    } else {\n        result = undefined;\n    }\n\n    if (!keys.length) {\n        return result;\n    }\n    get(result, keys);\n}\n\nfunction parseOptions(method: ?(Method | PartialOptions), url: ?(string | PartialOptions), options: ?PartialOptions): PartialOptions {\n    method = method ? (isObj(method) ? method : { method }) : {};\n    url = url ? (isObj(url) ? url : { url }) : {};\n    options = options || {};\n\n    return {\n        ...options,\n        ...url,\n        ...method,\n    }\n}\n\nfunction flattenToQueryParams(data: Data | Array<FormValue>, prefix: string = ''): { [string]: string | Blob | File } {\n    let params = {};\n\n    if (isArr(data)) {\n        data.forEach(item => {\n            let paramKey = `${prefix}[]`;\n\n            if (isObj(item) && !isFile(item)) {\n                params = {\n                    ...params,\n                    ...flattenToQueryParams(item, paramKey)\n                };\n                return;\n            }\n\n            params[paramKey] = isFile(item) ? item : formValueToString(item);\n        })\n    } else {\n        Object.keys(data).forEach(key => {\n            let item = data[key];\n\n            let paramKey = prefix ? `${prefix}[${key}]` : '' + key;\n\n            if (isObj(item) && !isFile(item)) {\n                params = {\n                    ...params,\n                    ...flattenToQueryParams(item, paramKey)\n                };\n                return;\n            }\n\n            params[paramKey] = isFile(item) ? item : formValueToString(item);\n        });\n    }\n\n    return params;\n}\n\nfunction formValueToString(value: PrimitiveFormValue): string {\n    if (typeof value === 'boolean') {\n        return ''+(+value);\n    }\n    if (typeof value === 'number') {\n        return value.toString();\n    }\n    return value || '';\n}\n\nfunction bubbleError(error: Error | Object): Promise<Object> {\n    if (error instanceof Error) {\n        throw error;\n    }\n    return Promise.reject(error);\n}\n\nfunction isValidErrorObject(errors) {\n    return !errors ||\n        typeof errors !== 'object' ||\n        !Object.keys(errors).length ||\n        Object.values(errors).some(error => {\n            if (isArr(error)) {\n                return error.some(message => !isStr(message));\n            }\n            return !isStr(error);\n        });\n}\n\nclass Form {\n\n    _errors: Errors;\n\n    _data: Data;\n    _dataCb: ?DataCb;\n    _originalData: Data;\n    _originalConstantData: Data;\n    _options: Options;\n\n    static defaultOptions: Options = {\n        // The default method type used by the submit method\n        method: 'post',\n\n        // If set any relative urls will be appended to the baseUrl\n        baseUrl: '',\n\n        // The url to submit the form\n        url: '',\n\n        // The endpoint to use for all graphql queries\n        graphql: 'graphql',\n\n        // A callback to implement custom HTTP logic.\n        // It is recommended to use this option so the form can utilise your HTTP library.\n        // The callback should return a promise that the form can use to handle the response.\n        sendWith: http,\n\n        // Set to true if you want the form to submit the data as a json object.\n        // This will pass the data as a JavaScript object to the sendWith callback so it is up to you to stringify it for your HTTP library.\n        // If the data contains a File or Blob object the data will be a FormData object regardless of this option (unless strictMode is true).\n        useJson: false,\n\n        // If set to true the form will use follow the `useJson` option even if the data contains non JSONable values (including files).\n        strictMode: false,\n\n        // The status code for which the form should handle validation errors.\n        isValidationError: ({ status }) => status === 422,\n\n        // A callback to format the data before sending it.\n        formatData: (data) => data,\n\n        // A callback that should turn the error response into an object of field names and their validation errors.\n        formatErrorResponse: (response) => {\n            let data = response.data || response.response;\n            if (typeof data === 'string') {\n                try {\n                    data = JSON.parse(data);\n                } catch (e) {\n                    throw new Error('Unable to find errors in the response');\n                }\n            }\n            let errors: ErrorValues = data.errors;\n            if (isValidErrorObject(errors)) {\n                throw new Error('Unable to find errors in the response');\n            }\n            return errors;\n        },\n\n        // The number of milliseconds to wait before clearing the error messages.\n        // When timeout is false the error messages will stay indefinitely.\n        timeout: false,\n\n        // When set to true the errors for a field will be cleared when that field's value is updated.\n        autoRemoveError: true,\n\n        // When set to true, the data will be reverted to it's original values after a successful request.\n        clear: true,\n\n        // When set to true, no errors will be recorded.\n        quiet: false,\n\n        // If clone is set to false any nested objects and arrays will be stored in the form by reference.\n        clone: true,\n\n        // If the form is called with a callback constructor then any data added\n        // later will be included when the form is reset. Set this to false to\n        // have the form reset using just the callback.\n        addAppendToDataCallback: true,\n    };\n\n    static setOptions = function (options: Options) {\n        Form.defaultOptions = {\n            ...Form.defaultOptions,\n            ...options\n        };\n    };\n\n    constructor(data: Data|DataCb, options: ?Options) {\n        this.setOptions(options);\n\n        if (isFunc(data)) {\n            this._dataCb = data;\n            data = data();\n        }\n\n        this._originalData = {};\n        this._originalConstantData = {};\n        this._data = {};\n\n        // $FlowFixMe\n        this.append(data, undefined, false, false);\n\n        this._errors = new Errors();\n    }\n\n    setOptions(options: ?Options) {\n        this._options = this._options || Form.defaultOptions;\n        if (options) {\n            this._options = {\n                ...this._options,\n                ...options,\n            }\n        }\n    }\n\n    append(key: string | Data, value: FormValue, constant: ?boolean = false, addToDataCallback: ?boolean = true): Form {\n        if (this._dataCb && !constant && this._options.addAppendToDataCallback && addToDataCallback) {\n            const originalCb = this._dataCb;\n            this._dataCb = () => {\n                const data = originalCb();\n                if (isObj(key)) {\n                    return {\n                        ...data,\n                        ...key\n                    };\n                }\n                return {\n                    ...data,\n                    [key]: value,\n                };\n            }\n        }\n\n        if (isObj(key)) {\n            Object.keys(key).forEach(field => {\n                this.append(field, key[field], constant, false);\n            });\n            return this;\n        }\n\n        value = this.parseData(value);\n        if (constant) {\n            set(this._originalConstantData, key, value);\n        } else {\n            set(this._originalData, key, this.parseData(value));\n        }\n        if (!constant) {\n            set(this._data, key, value);\n            this.defineProperty(key);\n        } else {\n            Object.defineProperty(\n                this,\n                key,\n                {\n                    get: () => undefined,\n                    set: () => {\n                        throw new Error(`The \"${key}\" value has been set as constant and cannot be modified`);\n                    }\n                }\n            );\n        }\n\n        return this;\n    }\n\n    defineProperty(key: string) {\n        Object.defineProperty(\n            this,\n            key,\n            {\n                configurable: true,\n                enumerable: true,\n                get: () => get(this._data, key),\n                set: (newValue: FormValue) => {\n                    this.setData(key, newValue);\n                }\n            }\n        );\n    }\n\n    constantData(key: string | Data, value: FormValue): Form {\n        return this.append(key, value, true, false);\n    }\n\n    getData(): Data {\n        return {\n            ...this._data,\n            ...this._originalConstantData,\n        }\n    }\n\n    setData(key: string, value: FormValue) {\n        set(this._data, key, value);\n        if (this._options.autoRemoveError) {\n            this._errors.clear(key);\n        }\n    }\n\n    errors(): Errors {\n        return this._errors;\n    }\n\n    reset(): Form {\n        const originalData = this._dataCb ? this._dataCb() : this._originalData;\n\n        for (let field in this._data) {\n            // $FlowFixMe\n            delete this[field];\n        }\n\n        this._originalData = {};\n        this._data = {};\n\n        this.append(originalData, undefined, false, false);\n\n        this._errors.clear();\n\n        return this;\n    }\n\n    clear(field: string): Form {\n        if (hasOwn(this, field)) {\n            set(this._data, field, emptyValue(get(this._data, field)));\n        }\n        return this;\n    }\n\n    parseData(data: FormValue): FormValue {\n        return this._options.clone ? clone(data) : data;\n    }\n\n    addFileFromEvent(event: Event | DragEvent, key: ?string): Form {\n        let node = event.target;\n        if (!(node instanceof HTMLInputElement)) {\n            throw new Error('Incompatible event target, must be of type HTMLInputElement');\n        }\n        if (!key) {\n            key = node.name;\n        }\n        if (key in this && (node.value !== '')) {\n            if (event instanceof DragEvent) {\n                this.setData(key, event.dataTransfer && event.dataTransfer.files.length && event.dataTransfer.files[0]);\n            } else {\n                this.setData(key, node.files && node.files.length && node.files[0]);\n            }\n            node.value = '';\n        }\n        return this;\n    }\n\n    post(url: string | Options, options: ?Options): Promise<any> {\n        return this.submit('post', url, options);\n    }\n\n    put(url: string | Options, options: ?Options): Promise<any> {\n        return this.submit('put', url, options);\n    }\n\n    patch(url: string | Options, options: ?Options): Promise<any> {\n        return this.submit('patch', url, options);\n    }\n\n    delete(url: string | Options, options: ?Options): Promise<any> {\n        return this.submit('delete', url, options);\n    }\n\n    get(url: string | Options, options: ?Options): Promise<any> {\n        return this.submit('get', url, options);\n    }\n\n    graphql(query: string, options: ?Options): Promise<any> {\n        options = options || {};\n        const originalFormatDataCallback = options.formatData || this._options.formatData;\n\n        options.url = options.graphql || this._options.graphql;\n\n        options.useJson = !this.hasFile();\n\n        options.formatData = (data) => {\n            data = originalFormatDataCallback ? originalFormatDataCallback(data) : data;\n            const operations = {\n                query,\n                variables: data,\n            };\n\n            if (!this.hasFile()) {\n                return operations;\n            }\n            const { clone, files } = extractFiles(data);\n            operations.variables = clone;\n            return {\n                operations: JSON.stringify(operations),\n                map: JSON.stringify(arrayToObject(Array.from(files.values()))),\n                ...arrayToObject(Array.from(files.keys())),\n            };\n        };\n        return this.post(options);\n    }\n\n    submit(method: Method | Options, url: ?string | Options, options: ?Options): Promise<any> {\n        options = parseOptions(method, url, options);\n        const requestOptions = {\n            ...this._options,\n            ...options,\n        };\n\n        let formData, data = requestOptions.formatData(this.getData());\n        if (this.shouldConvertToFormData(requestOptions)) {\n            formData = new FormData();\n\n            let params = flattenToQueryParams(data);\n\n            Object.keys(params).forEach(key => {\n                formData.append(key, params[key]);\n            });\n\n            data = formData;\n        }\n\n        let httpAdapter = requestOptions.sendWith;\n\n        return httpAdapter(requestOptions.method, this.buildBaseUrl(requestOptions), data, requestOptions).then(response => {\n            if (requestOptions.isValidationError(response)) {\n                this.onFail(response, requestOptions);\n            } else {\n                this.onSuccess(requestOptions);\n            }\n            return response;\n        }).catch(error => {\n            if (requestOptions.isValidationError(error)) {\n                this.onFail(error, requestOptions);\n            }\n            return bubbleError(error);\n        });\n    }\n\n    shouldConvertToFormData(options: ?Options) {\n        options = options || this._options;\n        if (options.strictMode) {\n            return !options.useJson;\n        }\n        return !options.useJson || this.hasFile();\n    }\n\n    hasFile(): boolean {\n        return containsFile(this.getData());\n    }\n\n    onSuccess(options: ?Options) {\n        options = options || this._options;\n        if (options.clear) {\n            this.reset();\n        }\n    }\n\n    onFail(error: XMLHttpRequest, options: ?Options) {\n        options = options || this._options;\n        if (!options.quiet) {\n            let errors = options.formatErrorResponse(error);\n            this._errors.record(errors, options.timeout);\n            if (this._errors.hasElements()) {\n                this._errors.scrollToFirst();\n            }\n        }\n    }\n\n    buildBaseUrl(options: ?Options) {\n        options = options || this._options;\n        if (options.url.includes('://')) {\n            return options.url;\n        }\n        let baseUrl = options.baseUrl;\n        let relativeUrl = options.url;\n\n        baseUrl = baseUrl.replace(/\\/+$/g, '');\n        relativeUrl = relativeUrl.replace(/^\\/+/g, '');\n\n        return `${baseUrl}/${relativeUrl}`;\n    }\n\n    makeUrl(options: ?Options): string {\n        let url = this.buildBaseUrl(options);\n        let queryStart = url.includes('?') ? '&' : '?';\n        let fullUrl = url + queryStart;\n        let properties = [];\n        let data = this.getData();\n\n        let params = flattenToQueryParams(data);\n\n        Object.keys(params).forEach(key => {\n            let item = params[key];\n\n            if (isFile(item)) {\n                throw new Error('Cannot convert file to a string');\n            }\n\n            properties.push(key + (isNil(item) ? '' : `=${item}`));\n        });\n        return fullUrl + properties.join('&');\n    }\n\n    addElement(key: string, el: HTMLElement) {\n        this._errors.addElement(key, el);\n    }\n\n    removeElement(el: HTMLElement) {\n        this._errors.removeElement(el);\n    }\n\n    removeElementKey(key: string) {\n        this._errors.removeElementKey(key);\n    }\n}\n\n\nexport default Form;\n","// @flow\nimport type { Method } from './flow';\nimport type { Data } from \"./Form\";\n\ntype Options = {\n    method: Method,\n    url: string,\n}\n\nexport default function http(method: Method, url: string, data: FormData | Data, options: Options) {\n    let xhr = new XMLHttpRequest();\n\n    let response = new Promise<XMLHttpRequest>((resolve, reject) => {\n        xhr.onload = () => {\n            if (xhr.status >= 200 && xhr.status < 300) {\n                resolve(xhr);\n            } else {\n                reject(xhr);\n            }\n        };\n        xhr.onerror = () => reject(xhr);\n    });\n\n    xhr.open(method, url);\n    if (data instanceof FormData) {\n        xhr.setRequestHeader('Content-Type', 'multipart/form-data');\n        xhr.send(data);\n    } else {\n        xhr.setRequestHeader('Content-Type', 'application/json');\n        xhr.send(JSON.stringify(data));\n    }\n\n    return response;\n}"],"names":["root","factory","exports","module","define","amd","self","__esModule","ReactNativeFile","_ref","uri","name","type","this","extractFiles","value","path","clone","files","Map","addFile","paths","file","storedPaths","get","push","apply","set","File","Blob","_ReactNativeFile","prefix","FileList","Array","prototype","map","call","i","isArray","child","result","forEach","constructor","Object","_extractFiles","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","d","definition","key","o","defineProperty","enumerable","obj","prop","hasOwnProperty","r","Symbol","toStringTag","hasOwn","isFile","val","isArr","includes","isObj","target","keys","isNil","isStr","containsFile","length","arrayToObject","array","item","index","errors","elements","has","field","RegExp","some","test","any","getFirst","matchWildCards","error","regExpStr","replace","regExp","keyErrors","concat","add","force","record","timeout","window","setTimeout","clear","addElement","el","removeElement","element","filter","removeElementKey","hasElements","scrollToFirst","options","behavior","inline","find","rx","expression","boundingBox","getBoundingClientRect","top","bottom","innerHeight","document","documentElement","clientHeight","isInViewport","scrollIntoView","split","shift","flattenToQueryParams","data","params","paramKey","formValueToString","toString","Form","setOptions","Function","_dataCb","_originalData","_originalConstantData","_data","append","_errors","Errors","_options","defaultOptions","constant","addToDataCallback","addAppendToDataCallback","originalCb","parseData","Error","configurable","newValue","setData","constantData","getData","autoRemoveError","reset","originalData","original","addFileFromEvent","event","node","HTMLInputElement","DragEvent","dataTransfer","post","url","submit","put","patch","delete","graphql","query","originalFormatDataCallback","formatData","useJson","hasFile","operations","variables","JSON","stringify","from","values","method","parseOptions","requestOptions","formData","shouldConvertToFormData","FormData","httpAdapter","sendWith","buildBaseUrl","then","response","isValidationError","onFail","onSuccess","catch","Promise","reject","bubbleError","strictMode","quiet","formatErrorResponse","baseUrl","relativeUrl","makeUrl","queryStart","fullUrl","properties","join","xhr","XMLHttpRequest","resolve","onload","status","onerror","open","setRequestHeader","send","parse","e","message","isValidErrorObject"],"sourceRoot":""}